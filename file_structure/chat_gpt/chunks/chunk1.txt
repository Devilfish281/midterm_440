Developer: Developer: # Project Title
- class elective advisor Project class 491

# Role and Objective
- Serve as a Python developer working on the 'Smart Elective Advisor: AI-Driven Course Selection Tool for CS Students' using modern Python tooling and best practices.
- **Programming language:** Python (already installed).
- **Manages virtual environments:** Poetry (already installed).
- **Package installer for Python:** Poetry.
- **Operating System:** Windows 11.
- **Framework:** LangChain, LangGraph.

# Initial Checklist
- Begin each task with a concise checklist (3-7 bullets) of conceptual sub-tasks to ensure all steps and requirements are addressed.

# Instructions
- Use Visual Studio Code on Windows 11 to develop in Python.
- Manage packages and virtual environments with Poetry.
- Use Tkinter for the GUI, SQLite for the database, and incorporate LangChain, LangGraph, and OpenAI (gpt-4o) for AI components.
- Employ Git and GitHub for version control.
- Use Sphinx for documentation generation.
- **Check my code for errors and suggest improvements.**

## Coding and Commenting Guidelines
- When adding new lines of code, annotate with `` at the end of the line.
- If a line is both added and modified, use only `#  Changed Code` at the end of the line.
- Do **not** comment on command-line instructions.
- Provide complete code context when submitting changes.
- When editing code:
  1. Clearly state any relevant assumptions.
  2. If feasible, create or execute minimal tests to verify changes, and validate results in 1-2 lines (proceed or self-correct as needed).
  3. Provide review-ready diffs.
  4. Follow the established project style conventions.
- **Only annotate a line with `#  Changed Code` if the line is different from the original; do not add `#  Changed Code` when the line remains unchanged.**

# Context
- **Project Directory:** C:/Users/Me/Documents/Python/CPSC491/Projects/class_elective_advisor_491
- **GitHub Repository:** https://github.com/Devilfish281/class_elective_advisor.git
- All required programs and libraries (Python, Tkinter, Poetry, Git) are already installed.

# Output Format
- Default to plain text output unless Markdown is specifically required.
- When using Markdown for code, employ fenced code blocks with correct language tags (e.g., ```python).
- File, directory, function, and class names should appear in backticks if referenced.
- Escape math notation if present.

# Verbosity
- Use concise summaries for general output.
- For code, prioritize high verbosity: use descriptive names, clear logic, and meaningful comments.

# Reasoning Effort
- Set reasoning_effort according to task complexity (minimal for simple, medium/high for complex tasks); tool interactions and code edits should be terse, final outputs more complete as needed.

# Stop Conditions
- Tasks are complete when all success criteria and instructions have been addressed.
- In cases of uncertainty, proceed with the most logical approach and document any relevant assumptions.
- Only finish when the user's specification and project conventions are fully satisfied.

********************************
Check my code for errors and improvements.



The File structure for my program is BELOW:
├── C:\Users\Me\Documents\Python\CPSC440\Projects\midterm_440/
│   ├── .gitignore
│   ├── README.md
│   ├── poetry.lock
│   └── pyproject.toml
    ├── src/
        └── midterm_440/
            └── __init__.py
            └── numeric_core/
                ├── __init__.py
                ├── alu.py
                ├── bits.py
                ├── fpu_f32.py
                ├── interfaces.py
                ├── mdu.py
                ├── shifter.py
                └── twos.py
                └── internal/
    └── tests/
        ├── __init__.py
        └── conftest.py
        ├── data/
        └── unit/
            ├── smoke_mdu.py
            ├── test_alu.py
            ├── test_bits.py
            ├── test_fpu_f32.py
            ├── test_mdu.py
            ├── test_shifter.py
            └── test_twos.py

########################################
Here is my code for __init__.py BELOW:
########################################

```python
```

########################################
Here is my code for __init__.py BELOW:
########################################

```python
```

########################################
Here is my code for alu.py BELOW:
########################################

```python
# src/midterm_440/numeric_core/alu.py
"""Ripple-carry ALU for ADD/SUB with flags N,Z,C,V (RV32).

The ALU operates on 32-bit bit arrays (LSB first) using 1-bit full adders.
No host ``+``/``-`` or shifts are used in the final implementation.

Overflow (V) rules (two's complement):
- ADD: overflow iff operands share sign and result sign differs.
- SUB: implement as ``a + (~b + 1)`` and apply ADD rule.

Flags:
- N: msb(result)
- Z: 1 if all result bits are 0
- C: carry out of MSB (for subtraction via a + (~b + 1), C=1 implies no borrow)
- V: signed overflow as above
"""

from typing import List, Tuple


def _validate_bits_32(a: List[int], b: List[int]) -> None:
    """Quick checks: lists, 32 bits, only 0/1."""
    if not (isinstance(a, list) and isinstance(b, list)):
        raise ValueError("a and b must be lists")
    if len(a) != 32 or len(b) != 32:
        raise ValueError("a and b must be 32 bits long")
    for x in a + b:
        if x not in (0, 1):
            raise ValueError("bits must be 0/1")


def _add_bits_with_cin(
    a: List[int], b: List[int], cin0: int
) -> Tuple[List[int], int, int, int, int]:
    """Full-adder ripple with selectable initial carry-in (0 or 1)."""
    _validate_bits_32(a, b)
    out = [0] * 32
    cin = cin0
    carry_into_msb = 0
    for i in range(32):
        ai = a[i]
        bi = b[i]
        axb = ai ^ bi
        s = axb ^ cin
        cout = (ai & bi) | (cin & axb)
        out[i] = s
        if i == 31:
            carry_into_msb = cin
            carry_out_msb = cout
        cin = cout
    N = out[31]
    Z = 1 if all(bit == 0 for bit in out) else 0
    C = cin
    V = 1 if carry_into_msb != carry_out_msb else 0
    return out, N, Z, C, V


def add_bits(a: List[int], b: List[int]) -> Tuple[List[int], int, int, int, int]:
    """Add two 32-bit vectors using a ripple of 1-bit full adders.

    :param List[int] a: 32-bit list, LSB first.
    :param List[int] b: 32-bit list, LSB first.
    :returns: ``(sum_bits, N, Z, C, V)``.
    :rtype: Tuple[List[int], int, int, int, int]
    """
    return _add_bits_with_cin(a, b, 0)


def _invert_bits(bits: List[int]) -> List[int]:
    """Bitwise NOT for 0/1 lists."""
    return [0 if b == 1 else 1 for b in bits]


def sub_bits(a: List[int], b: List[int]) -> Tuple[List[int], int, int, int, int]:
    """Subtract ``b`` from ``a`` via two's-complement addition.

    :param List[int] a: Minuend, 32-bit list, LSB first.
    :param List[int] b: Subtrahend, 32-bit list, LSB first.
    :returns: ``(diff_bits, N, Z, C, V)``; for two's-complement, C=1 means no borrow.
    :rtype: Tuple[List[int], int, int, int, int]
    """
    _validate_bits_32(a, b)
    b_inv = _invert_bits(b)
    diff, N, Z, C, V = _add_bits_with_cin(a, b_inv, 1)
    return diff, N, Z, C, V```

########################################
Here is my code for bits.py BELOW:
########################################

```python
# src/midterm_440/numeric_core/bits.py
"""Bit-array utilities for the Midterm Numeric Ops Simulator.

This module defines helpers for representing unsigned 32-bit values as
lists of bits (least significant bit first) and for pretty-printing.

This reduces bugs and makes tests readable.

.. important::
   To keep implementation tractable, this module permits bitwise reads
   (``&``, ``>>``) solely for conversion/formatting. Core arithmetic
   (ALU/MDU/FPU) must still avoid host arithmetic/shift ops as required.
"""

from typing import List

_HEX_DIGITS = "0123456789ABCDEF"
_NIBBLE_TO_HEX = {
    (0, 0, 0, 0): "0",
    (0, 0, 0, 1): "1",
    (0, 0, 1, 0): "2",
    (0, 0, 1, 1): "3",
    (0, 1, 0, 0): "4",
    (0, 1, 0, 1): "5",
    (0, 1, 1, 0): "6",
    (0, 1, 1, 1): "7",
    (1, 0, 0, 0): "8",
    (1, 0, 0, 1): "9",
    (1, 0, 1, 0): "A",
    (1, 0, 1, 1): "B",
    (1, 1, 0, 0): "C",
    (1, 1, 0, 1): "D",
    (1, 1, 1, 0): "E",
    (1, 1, 1, 1): "F",
}


def _validate_bits_32(bits: List[int]) -> None:
    """Internal: ensure a 32-length 0/1 list (LSB first).

    :param List[int] bits: Candidate bit list.
    :raises ValueError: If malformed.
    """
    if not isinstance(bits, list):
        raise ValueError("bits must be a list")
    if len(bits) != 32:
        raise ValueError("bits must contain exactly 32 elements")
    for b in bits:
        if b not in (0, 1):
            raise ValueError("bits must contain only 0 or 1")


def u32_to_bits(value: int) -> List[int]:
    """Convert an unsigned 32-bit integer to a 32-length bit list (LSB first).

    :param int value: Unsigned integer expected in range ``[0, 2**32-1]``.
    :returns: Bit list ``bits[0]`` = LSB, ``bits[31]`` = MSB.
    :rtype: List[int]
    :raises ValueError: If value is outside 32-bit unsigned range.
    """
    if not isinstance(value, int):
        raise ValueError("value must be an int")
    if value < 0 or value > 0xFFFF_FFFF:
        raise ValueError("value must be in 0..0xFFFFFFFF")

    bits = [0] * 32
    for i in range(32):
        bits[i] = (value >> i) & 1
    return bits


def bits_to_u32(bits: List[int]) -> int:
    """Convert a 32-length bit list (LSB first) to an unsigned 32-bit integer.

    :param List[int] bits: Exactly 32 elements, each 0 or 1.
    :returns: Unsigned 32-bit integer.
    :rtype: int
    :raises ValueError: If length != 32 or elements are not 0/1.
    """
    _validate_bits_32(bits)
    value = 0
    for i in range(32):
        if bits[i]:
            value |= 1 << i
    return value


def pretty_bin32(bits: List[int]) -> str:
    """Return a grouped binary string like ``00000000_00000000_00000000_00000000``.

    Bytes are grouped from MSB to LSB, separated by underscores,
    with each byte printed MSB-first inside the group.

    :param List[int] bits: 32-bit list, LSB first.
    :returns: Human-friendly grouped binary string.
    :rtype: str
    """
    _validate_bits_32(bits)
    msb_first = "".join("1" if b else "0" for b in reversed(bits))
    groups = [msb_first[i : i + 8] for i in range(0, 32, 8)]
    return "_".join(groups)


def pretty_hex32(bits: List[int]) -> str:
    """Return a zero-padded hex string like ``0xDEADBEEF`` (manual nibbles).

    :param List[int] bits: 32-bit list, LSB first.
    :returns: Hex string with prefix ``0x``.
    :rtype: str
    """
    _validate_bits_32(bits)
    msb_first = list(reversed(bits))
    hex_chars: List[str] = []
    for i in range(0, 32, 4):
        n4 = tuple(int(c) for c in msb_first[i : i + 4])
        if len(n4) != 4:
            raise ValueError("internal error: nibble length != 4")
        hex_chars.append(_NIBBLE_TO_HEX[n4])
    return "0x" + "".join(hex_chars)


def main() -> int:
    """Small demo you can run by executing this file directly."""
    from midterm_440.numeric_core.bits import (
        bits_to_u32,
        pretty_bin32,
        pretty_hex32,
        u32_to_bits,
    )

    b = u32_to_bits(0xDEADBEEF)
    print(pretty_bin32(b))
    print(pretty_hex32(b))
    print(hex(bits_to_u32(b)))
    return 0


if __name__ == "__main__":

    import sys
    from pathlib import Path

    here = Path(__file__).resolve()
    project_root = here.parents[2]
    src_dir = project_root / "src"

    if src_dir.name == "src" and src_dir.exists():
        sys.path.insert(0, str(src_dir))

    raise SystemExit(main())```

########################################
Here is my code for fpu_f32.py BELOW:
########################################

```python
# src/midterm_440/numeric_core/fpu_f32.py
"""IEEE 754 float32 pack/unpack and arithmetic (add/sub/mul).

Implements bit-level operations: pack/unpack (s|exp|frac), align, add/sub on
extended significands, normalize, and round with **RoundTiesToEven (RNE)**.

Flags surfaced for grading: overflow, underflow, invalid (and optionally inexact).
"""

from typing import Dict, List


def pack_f32(value: float) -> Dict[str, object]:
    """Pack a Python decimal value into an IEEE-754 binary32 bit pattern.

    :param float value: Decimal input; treat special cases (±0, ±inf, NaN).
    :returns: ``{'bits': List[int], 'fields': {'s': int, 'exp': List[int], 'frac': List[int]}}``.
    :rtype: Dict[str, object]
    """
    raise NotImplementedError("pack_f32 not implemented")


def unpack_f32(bits: List[int]) -> Dict[str, object]:
    """Unpack a 32-bit IEEE-754 pattern into a Python decimal value.

    :param List[int] bits: 32 bits, LSB first.
    :returns: ``{'value': float, 'class': str}`` (e.g., 'normal','subnormal','zero','inf','nan').
    :rtype: Dict[str, object]
    """
    raise NotImplementedError("unpack_f32 not implemented")


def fadd_f32(a_bits: List[int], b_bits: List[int]) -> Dict[str, object]:
    """Float32 addition via align → add → normalize → round (RNE).

    :param List[int] a_bits: Operand A, 32 bits LSB first.
    :param List[int] b_bits: Operand B, 32 bits LSB first.
    :returns: ``{'res_bits': List[int], 'flags': {'overflow': int, 'underflow': int, 'invalid': int}, 'trace': List[dict]}``.
    :rtype: Dict[str, object]
    """
    raise NotImplementedError("fadd_f32 not implemented")


def fsub_f32(a_bits: List[int], b_bits: List[int]) -> Dict[str, object]:
    """Float32 subtraction via add with sign inversion and standard steps.

    :param List[int] a_bits: Operand A, 32 bits LSB first.
    :param List[int] b_bits: Operand B, 32 bits LSB first.
    :returns: Same schema as :func:`fadd_f32`.
    :rtype: Dict[str, object]
    """
    raise NotImplementedError("fsub_f32 not implemented")


def fmul_f32(a_bits: List[int], b_bits: List[int]) -> Dict[str, object]:
    """Float32 multiplication with normalization and RNE rounding.

    :param List[int] a_bits: Operand A, 32 bits LSB first.
    :param List[int] b_bits: Operand B, 32 bits LSB first.
    :returns: ``{'res_bits': List[int], 'flags': {...}, 'trace': List[dict]}``.
    :rtype: Dict[str, object]
    """
    raise NotImplementedError("fmul_f32 not implemented")```

########################################
Here is my code for interfaces.py BELOW:
########################################

```python
# src/midterm_440/numeric_core/interfaces.py
"""Public API surface for the Midterm Numeric Core.

This thin layer centralizes import paths for the numeric core so the
later CPU project can integrate a stable, pure-functional interface.
"""

from typing import Any, Dict, List, Tuple

try:
    from .alu import add_bits, sub_bits
    from .bits import bits_to_u32, pretty_bin32, pretty_hex32, u32_to_bits
    from .fpu_f32 import fadd_f32, fmul_f32, fsub_f32, pack_f32, unpack_f32
    from .mdu import div_restoring, mul_shift_add
    from .shifter import sll_bits, sra_bits, srl_bits
    from .twos import (
        decode_twos_complement,
        encode_twos_complement,
        sign_extend,
        zero_extend,
    )
except Exception:
    pass


def main() -> int:
    """Optional CLI entry point for manual smoke tests.

    :returns: Process exit code (0 success).
    :rtype: int
    """
    return 0```

########################################
Here is my code for mdu.py BELOW:
########################################

```python
# src/midterm_440/numeric_core/mdu.py
"""Multiply/Divide Unit (MDU) for RV32M using bit-level algorithms.

We do classic **shift-add** for MUL and **restoring division** for DIV.
Everything uses 0/1 lists (LSB first) and ripple-carry adders.

RISC-V DIV rules to cover in flags/edges (summarized):
- DIV/DIVU by zero => quotient all 1s (0xFFFFFFFF), remainder = dividend.
- Signed DIV of INT_MIN by -1 => quotient INT_MIN, remainder 0 (saturates).
These match the M extension semantics.
(See RISC-V M docs and guides.)
"""
from typing import Dict, List, Tuple

from midterm_440.numeric_core.alu import add_bits, sub_bits
from midterm_440.numeric_core.bits import bits_to_u32, u32_to_bits
from midterm_440.numeric_core.shifter import sll_bits, srl_bits

MASK32 = 0xFFFF_FFFF
INT32_MIN = 0x80000000


def _check32(bits: List[int]) -> None:
    if not isinstance(bits, list) or len(bits) != 32:
        raise ValueError("need 32 bits")
    for b in bits:
        if b not in (0, 1):
            raise ValueError("bits must be 0/1")


def _not_bits(bits: List[int]) -> List[int]:
    return [0 if b == 1 else 1 for b in bits]


def _add_n(a: List[int], b: List[int]) -> Tuple[List[int], int]:
    """Add same-length bit lists, return (sum_bits, carry_out)."""
    if len(a) != len(b):
        raise ValueError("lengths must match")
    out = [0] * len(a)
    cin = 0
    for i in range(len(a)):
        ai, bi = a[i], b[i]
        axb = ai ^ bi
        s = axb ^ cin
        cout = (ai & bi) | (cin & axb)
        out[i] = s
        cin = cout
    return out, cin


def _sub_n(a: List[int], b: List[int]) -> Tuple[List[int], int]:
    """Compute a - b as a + (~b + 1); returns (diff, borrow_flag_like)."""
    nb = _not_bits(b)
    tmp, cin = _add_n(a, nb)
    diff, cin2 = _add_n(tmp, [1] + [0] * (len(a) - 1))
    borrow = 0 if cin2 == 1 else 1
    return diff, borrow


def _sll_n(bits: List[int], k: int) -> List[int]:
    out = bits[:]
    stages = (1, 2, 4, 8, 16, 32, 64)
    for idx, st in enumerate(stages):
        if (k >> idx) & 1:
            tmp = [0] * len(out)
            for i in range(len(out)):
                if i >= st:
                    tmp[i] = out[i - st]
            out = tmp
    return out


def _srl_n(bits: List[int], k: int, fill: int = 0) -> List[int]:
    out = bits[:]
    stages = (1, 2, 4, 8, 16, 32, 64)
    for idx, st in enumerate(stages):
        if (k >> idx) & 1:
            tmp = [fill] * len(out)
            for i in range(len(out)):
                j = i + st
                if j < len(out):
                    tmp[i] = out[j]
            out = tmp
    return out


def _sign_extend_to_64(x: List[int]) -> List[int]:
    sign = x[31]
    return x[:] + [sign] * 32


def _zero_extend_to_64(x: List[int]) -> List[int]:
    return x[:] + [0] * 32


def _twos_neg(bits: List[int]) -> List[int]:
    inv = _not_bits(bits)
    res, _ = _add_n(inv, [1] + [0] * (len(bits) - 1))
    return res


def _is_zero(bits: List[int]) -> bool:
    return all(b == 0 for b in bits)


def mul_shift_add(rs1_bits: List[int], rs2_bits: List[int]) -> Dict[str, object]:
    """Signed 32×32 → low32 product using classic shift-add with trace.
    Trace shows step
    Overflow flag = 1 when the true 64-bit signed product doesn't fit in 32-bit signed.
    (Shift–add idea: add shifted multiplicand when current multiplier bit is 1.)
    """
    _check32(rs1_bits)
    _check32(rs2_bits)
    trace: List[dict] = []
    a64 = _sign_extend_to_64(rs1_bits)
    b32 = rs2_bits[:]
    acc = [0] * 64
    for i in range(32):
        add_now = 1 if b32[i] == 1 else 0
        if add_now:
            addend = _sll_n(a64, i)
            acc, _ = _add_n(acc, addend)
        low32 = acc[:32]
        hi32 = acc[32:]
        trace.append(
            {
                "step": i,
                "mul_bit": int(b32[i]),
                "added": add_now,
                "acc_low32_hex": f"0x{bits_to_u32(low32):08X}",
                "acc_hi32_hex": f"0x{bits_to_u32(hi32):08X}",
            }
        )
    rd_bits = acc[:32]
    sign32 = rd_bits[31]
    overflow = 0
    for j in range(32, 64):
        if acc[j] != sign32:
            overflow = 1
            break
    return {"rd_bits": rd_bits, "overflow": overflow, "trace": trace}


def _cmp_unsigned(a: List[int], b: List[int]) -> int:
    """Compare same-length unsigned bit lists (MSB first compare)."""
    assert len(a) == len(b)
    for i in range(len(a) - 1, -1, -1):
        if a[i] != b[i]:
            return 1 if a[i] > b[i] else -1
    return 0


def _abs_sign(bits: List[int]) -> Tuple[List[int], int]:
    """Return (abs_bits, sign) for 32-bit two's complement input."""
    if bits[31] == 1:
        return _twos_neg(bits), 1
    else:
        return bits[:], 0


def _clip32(x: List[int]) -> List[int]:
    return x[:32]


def div_restoring(
    dividend_bits: List[int], divisor_bits: List[int], signed: bool = True
) -> Dict[str, object]:
    """Binary restoring division with 32 iterations and a simple trace.
    - If signed=True: handle signs like RISC-V DIV/REM (quot trunc toward 0; rem same sign as dividend).
    - Edge cases: div-by-zero and INT_MIN/-1 per RISC-V M.
    """
    _check32(dividend_bits)
    _check32(divisor_bits)
    flags = {"div_by_zero": 0, "overflow": 0}
    trace: List[dict] = []

    if _is_zero(divisor_bits):
        flags["div_by_zero"] = 1
        q_bits = [1] * 32
        r_bits = dividend_bits[:]
        return {
            "q_bits": q_bits,
            "r_bits": r_bits,
            "flags": flags,
            "trace": trace,
        }

    if signed:
        if (
            bits_to_u32(dividend_bits) == INT32_MIN
            and bits_to_u32(divisor_bits) == MASK32
        ):
            q_bits = u32_to_bits(INT32_MIN)
            r_bits = u32_to_bits(0)
            flags["overflow"] = 1
            return {
                "q_bits": q_bits,
                "r_bits": r_bits,
                "flags": flags,
                "trace": trace,
            }
        dvd_abs, dvd_sign = _abs_sign(dividend_bits)
        dvs_abs, dvs_sign = _abs_sign(divisor_bits)
        q_sign = dvd_sign ^ dvs_sign
    else:
        dvd_abs, dvs_abs = dividend_bits[:], divisor_bits[:]
        q_sign = 0

    R = [0] * 33
    Q = dvd_abs[:]
    D = dvs_abs[:]
    D33 = D[:] + [0]

    for step in range(32):
        msb_q = Q[31]
        R = [msb_q] + R[:32]
        Q = [0] + Q[:31]
        R_try, borrow = _sub_n(R, D33)
        if R_try[32] == 1:
            qb = 0
        else:
            R = R_try
            qb = 1
        Q[0] = qb
        trace.append(
            {
                "step": step,
                "qb": qb,
                "R_top_hex": f"0x{bits_to_u32(R[1:33]):08X}",
                "Q_hex": f"0x{bits_to_u32(Q):08X}",
            }
        )

    q_bits_unsigned = Q
    r_bits_unsigned = R[0:32]

    if signed and q_sign == 1:
        q_bits_unsigned = _twos_neg(q_bits_unsigned)
    if signed and (dividend_bits[31] == 1):
        if not _is_zero(r_bits_unsigned):
            r_bits_unsigned = _twos_neg(r_bits_unsigned)

    q_bits = _clip32(q_bits_unsigned)
    r_bits = _clip32(r_bits_unsigned)
    return {
        "q_bits": q_bits,
        "r_bits": r_bits,
        "flags": flags,
        "trace": trace,
    }```

########################################
Here is my code for shifter.py BELOW:
########################################

```python
# src/midterm_440/numeric_core/shifter.py
"""Logical and arithmetic shifters implemented without ``<<``/``>>``.

Implements SLL, SRL, SRA using either iterative shift-register style
or a barrel shifter built from stages (powers of two).
"""

from typing import List


def _validate_bits_32(bits: List[int]) -> None:
    if not isinstance(bits, list):
        raise ValueError("bits must be a list")
    if len(bits) != 32:
        raise ValueError("bits must have length 32")
    for b in bits:
        if b not in (0, 1):
            raise ValueError("bits must contain only 0/1")


def _validate_shamt(shamt: int) -> int:
    if not isinstance(shamt, int):
        raise ValueError("shamt must be an int")
    if shamt < 0 or shamt > 31:
        raise ValueError("shamt must be in 0..31")
    return shamt


def _shift_left_by_k(src: List[int], k: int, fill: int = 0) -> List[int]:
    """LSB-first: out[i] = src[i-k] if i>=k else fill."""
    out = [0] * 32
    for i in range(32):
        if i >= k:
            out[i] = src[i - k]
        else:
            out[i] = fill
    return out


def _shift_right_by_k(src: List[int], k: int, fill: int = 0) -> List[int]:
    """LSB-first: out[i] = src[i+k] if i+k<32 else fill."""
    out = [0] * 32
    for i in range(32):
        j = i + k
        if j < 32:
            out[i] = src[j]
        else:
            out[i] = fill
    return out


def sll_bits(bits: List[int], shamt: int) -> List[int]:
    """Shift left logical by ``shamt`` (insert zeros on the right).

    :param List[int] bits: 32-bit list, LSB first.
    :param int shamt: Shift amount in [0, 31].
    :returns: New 32-bit list after SLL.
    :rtype: List[int]
    """
    _validate_bits_32(bits)
    k = _validate_shamt(shamt)

    out = bits[:]
    stages = (1, 2, 4, 8, 16)
    for idx, stage in enumerate(stages):
        if (k >> idx) & 1:
            out = _shift_left_by_k(out, stage, fill=0)
    return out


def srl_bits(bits: List[int], shamt: int) -> List[int]:
    """Shift right logical by ``shamt`` (insert zeros on the left).

    :param List[int] bits: 32-bit list, LSB first.
    :param int shamt: Shift amount in [0, 31].
    :returns: New 32-bit list after SRL.
    :rtype: List[int]
    """
    _validate_bits_32(bits)
    k = _validate_shamt(shamt)

    out = bits[:]
    stages = (1, 2, 4, 8, 16)
    for idx, stage in enumerate(stages):
        if (k >> idx) & 1:
            out = _shift_right_by_k(out, stage, fill=0)
    return out


def sra_bits(bits: List[int], shamt: int) -> List[int]:
    """Shift right arithmetic by ``shamt`` (replicate original sign bit).

    :param List[int] bits: 32-bit list, LSB first.
    :param int shamt: Shift amount in [0, 31].
    :returns: New 32-bit list after SRA.
    :rtype: List[int]
    """
    _validate_bits_32(bits)
    k = _validate_shamt(shamt)

    sign = bits[31]
    out = bits[:]
    stages = (1, 2, 4, 8, 16)
    for idx, stage in enumerate(stages):
        if (k >> idx) & 1:
            out = _shift_right_by_k(out, stage, fill=sign)
    return out```

########################################
Here is my code for twos.py BELOW:
########################################

```python
# src/midterm_440/numeric_core/twos.py
"""Two's-complement tools for 32-bit values (RV32).

This file gives you simple helpers to work with signed 32-bit numbers.
You can turn a Python int into two's-complement bits and back.
You can also grow a smaller value to a bigger width by copying the sign
(sign-extend) or by adding zeros (zero-extend).

Reminder about overflow in two's-complement math:
- Overflow is about the sign being wrong, not about the carry bit.
- If you add two numbers with the same sign and the result flips sign,
  that means overflow.
Example: 0x7FFFFFFF + 1 → 0x80000000 has signed overflow.
"""

from typing import Dict, List

from midterm_440.numeric_core.bits import (
    bits_to_u32,
    pretty_bin32,
    pretty_hex32,
    u32_to_bits,
)

_INT32_MIN = -(1 << 31)
_INT32_MAX = (1 << 31) - 1
_MASK32 = 0xFFFF_FFFF


def _validate_bit_string_32(s: str) -> str:
    """Make sure we got a clean 32-bit '0'/'1' string. Underscores are ok.
    Returns the cleaned 32 characters (MSB..LSB).
    """
    if not isinstance(s, str):
        raise ValueError("bits_in must be a string or int")

    cleaned = s.replace("_", "").strip()
    if len(cleaned) != 32 or any(ch not in "01" for ch in cleaned):
        raise ValueError("binary string must be 32 characters of '0'/'1'")
    return cleaned


def encode_twos_complement(value: int) -> Dict[str, object]:
    """Turn a Python int into a 32-bit two's-complement pattern.

    :param int value: The number you want to encode (can be negative).
    :returns: A dictionary with:
              ``bin`` (str): 32 bits grouped like ``00000000_...``;
              ``hex`` (str): hex string like ``0x0000000D``;
              ``overflow_flag`` (int): 1 if value is outside -2^31..2^31-1.
    :rtype: Dict[str, object]

    Example: value = -13 → bin looks like 1111...0011, hex=0xFFFFFFF3.

    To get the two's-complement representation of a negative number (for an N-bit word):

    Write the absolute value in binary using N bits (pad with leading zeros).

    Flip every bit (0 → 1, 1 → 0).

    Add 1 to the flipped result (ignore any carry beyond N bits).

    Example: represent -5 in 8 bits.
    +5 in 8 bits = 00000101.
    Flip bits → 11111010.
    Add 1 → 11111011 (this is -5 in 8-bit two's-complement).

    """
    if not isinstance(value, int):
        raise ValueError("value must be an int")
    overflow = 0 if (_INT32_MIN <= value <= _INT32_MAX) else 1
    unsigned = value & _MASK32
    bits = u32_to_bits(unsigned)
    return {
        "bin": pretty_bin32(bits),
        "hex": pretty_hex32(bits),
        "overflow_flag": overflow,
    }


def decode_twos_complement(bits_in: object) -> Dict[str, int]:
    """Read a 32-bit pattern and return the signed value.

    :param object bits_in: A 32-char '0'/'1' string (underscores ok)
                           or an unsigned 32-bit integer.
    :returns: ``{'value': int}`` in [-2**31, 2**31-1].
    :rtype: Dict[str, int]

    Tip: If the top bit (bit 31) is 1, the number is negative.
    """
    if isinstance(bits_in, str):
        cleaned = _validate_bit_string_32(bits_in)
        bits = [1 if cleaned[31 - i] == "1" else 0 for i in range(32)]
        u = bits_to_u32(bits)
    elif isinstance(bits_in, int):
        if bits_in < 0 or bits_in > _MASK32:
            raise ValueError("integer input must be in 0..0xFFFFFFFF")
        u = bits_in
    else:
        raise ValueError("bits_in must be a 32-bit binary string or unsigned int")

    value = u if (u & (1 << 31)) == 0 else (u - (1 << 32))
    return {"value": value}


def sign_extend(bits: List[int], from_width: int, to_width: int) -> List[int]:
    """Grow a value by copying its sign bit.

    :param List[int] bits: Bits are LSB first (bits[0] is the rightmost bit).
    :param int from_width: How many low bits are the “real” value now.
    :param int to_width: New width (must be >= from_width).
    :returns: New list with length ``to_width``.

    Why this works: in two's complement, repeating the top bit keeps the value.
    (If sign=1, we fill with 1s; if sign=0, we fill with 0s.)
    """
    if not isinstance(bits, list) or any(b not in (0, 1) for b in bits):
        raise ValueError("bits must be a list of 0/1")
    if not (1 <= from_width <= len(bits)):
        raise ValueError("from_width must be in 1..len(bits)")
    if to_width < from_width:
        raise ValueError("to_width must be >= from_width")

    sign = bits[from_width - 1]
    out = bits[:from_width] + [sign] * (to_width - from_width)
    return out[:to_width]


def zero_extend(bits: List[int], from_width: int, to_width: int) -> List[int]:
    """Grow a value by adding zeros on the left.

    :param List[int] bits: Bits are LSB first (bits[0] is the rightmost bit).
    :param int from_width: How many low bits are the “real” value now.
    :param int to_width: New width (must be >= from_width).
    :returns: New list with length ``to_width``.

    Use this when you want an unsigned view or you know the value is non-negative.
    """
    if not isinstance(bits, list) or any(b not in (0, 1) for b in bits):
        raise ValueError("bits must be a list of 0/1")
    if not (1 <= from_width <= len(bits)):
        raise ValueError("from_width must be in 1..len(bits)")
    if to_width < from_width:
        raise ValueError("to_width must be >= from_width")

    out = bits[:from_width] + [0] * (to_width - from_width)
    return out[:to_width]


def main() -> int:
    """Small demo so you can run this file directly.

    This only runs when you execute the module as a script,
    not when you import it in other code.
    """
    print(encode_twos_complement(13))
    print(encode_twos_complement(-13))
    print(decode_twos_complement("00000000_00000000_00000000_00001101"))
    print(decode_twos_complement("11111111_11111111_11111111_11110011"))
    b = u32_to_bits(0xAB)
    print(sign_extend(b, 8, 12))
    print(zero_extend(b, 8, 12))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())```

########################################
Here is my code for __init__.py BELOW:
########################################

```python
```

########################################
Here is my code for conftest.py BELOW:
########################################

```python
```

########################################
Here is my code for smoke_mdu.py BELOW:
########################################

```python
from midterm_440.numeric_core.bits import bits_to_u32, u32_to_bits
from midterm_440.numeric_core.mdu import div_restoring, mul_shift_add



def hx(b):
    return f"0x{bits_to_u32(b):08X}"


a = u32_to_bits(12345678)
b = u32_to_bits(0xFFFFFFFF)
m = mul_shift_add(a, b)
print("MUL 12345678 * -1 -> rd =", hx(m["rd_bits"]), "overflow=", m["overflow"])

a = u32_to_bits(0xFFFFFFF9)
b = u32_to_bits(3)
d = div_restoring(a, b, signed=True)
print("DIV -7 / 3 -> q =", hx(d["q_bits"]), "r =", hx(d["r_bits"]), d["flags"])

a = u32_to_bits(0x80000000)
b = u32_to_bits(3)
du = div_restoring(a, b, signed=False)
print(
    "DIVU 0x80000000 / 3 -> q =", hx(du["q_bits"]), "r =", hx(du["r_bits"]), du["flags"]
)

a = u32_to_bits(123)
b = u32_to_bits(0)
dz = div_restoring(a, b, signed=True)
print("DIV 123 / 0 -> q =", hx(dz["q_bits"]), "r =", hx(dz["r_bits"]), dz["flags"])

a = u32_to_bits(0x80000000)
b = u32_to_bits(0xFFFFFFFF)
io = div_restoring(a, b, signed=True)
print("DIV INT_MIN/-1 -> q =", hx(io["q_bits"]), "r =", hx(io["r_bits"]), io["flags"])```

########################################
Here is my code for test_alu.py BELOW:
########################################

```python
# tests/unit/test_alu.py
from midterm_440.numeric_core.alu import add_bits, sub_bits
from midterm_440.numeric_core.bits import bits_to_u32, u32_to_bits


def bits_to_u32_hex(bits):
    return f"0x{bits_to_u32(bits):08X}"


def test_add_overflow_positive_edge():
    a = u32_to_bits(0x7FFFFFFF)
    b = u32_to_bits(0x00000001)
    res, N, Z, C, V = add_bits(a, b)
    assert bits_to_u32_hex(res) == "0x80000000"
    assert (V, C, N, Z) == (1, 0, 1, 0)


def test_sub_overflow_negative_edge():
    a = u32_to_bits(0x80000000)
    b = u32_to_bits(0x00000001)
    res, N, Z, C, V = sub_bits(a, b)
    assert bits_to_u32_hex(res) == "0x7FFFFFFF"
    assert (V, C, N, Z) == (1, 1, 0, 0)


def test_add_minus1_plus_minus1():
    a = u32_to_bits(0xFFFFFFFF)
    b = u32_to_bits(0xFFFFFFFF)
    res, N, Z, C, V = add_bits(a, b)
    assert bits_to_u32_hex(res) == "0xFFFFFFFE"
    assert (V, C, N, Z) == (0, 1, 1, 0)```

########################################
Here is my code for test_bits.py BELOW:
########################################

```python
# tests/unit/test_bits.py
import pytest

from midterm_440.numeric_core.bits import (
    bits_to_u32,
    pretty_bin32,
    pretty_hex32,
    u32_to_bits,
)


class TestBits:
    def test_round_trip_zero(self):
        b = u32_to_bits(0)
        assert len(b) == 32 and all(x in (0, 1) for x in b)
        assert bits_to_u32(b) == 0

    def test_round_trip_max(self):
        val = 0xFFFF_FFFF
        b = u32_to_bits(val)
        assert bits_to_u32(b) == val

    def test_specific_value_deadbeef(self):
        val = 0xDEAD_BEEF
        b = u32_to_bits(val)
        bin_str = pretty_bin32(b)
        assert isinstance(bin_str, str) and len(bin_str.replace("_", "")) == 32
        assert pretty_hex32(b) == "0xDEADBEEF"
        assert bits_to_u32(b) == val

    def test_invalid_range_negative(self):
        with pytest.raises(ValueError):
            u32_to_bits(-1)

    def test_invalid_range_too_large(self):
        with pytest.raises(ValueError):
            u32_to_bits(0x1_0000_0000)

    def test_bits_validation_length(self):
        with pytest.raises(ValueError):
            bits_to_u32([0, 1])

    def test_bits_validation_values(self):
        bad = [0] * 31 + [2]
        with pytest.raises(ValueError):
            bits_to_u32(bad)

    def test_formatting_zero(self):
        b = u32_to_bits(0)
        assert pretty_hex32(b) == "0x00000000"
        assert pretty_bin32(b) == "00000000_00000000_00000000_00000000"```

########################################
Here is my code for test_fpu_f32.py BELOW:
########################################

```python
```

########################################
Here is my code for test_mdu.py BELOW:
########################################

```python
```

########################################
Here is my code for test_shifter.py BELOW:
########################################

```python
# tests/unit/test_shifter.py
import pytest

from midterm_440.numeric_core.bits import bits_to_u32, u32_to_bits
from midterm_440.numeric_core.shifter import sll_bits, sra_bits, srl_bits



def _hex_u32(bits):
    return f"0x{bits_to_u32(bits):08X}"


def test_sll_basic():
    a = u32_to_bits(0x00000001)
    out = sll_bits(a, 1)
    assert _hex_u32(out) == "0x00000002"


def test_sll_drop_msb():
    a = u32_to_bits(0x80000000)
    out = sll_bits(a, 1)
    assert _hex_u32(out) == "0x00000000"


def test_srl_basic():
    a = u32_to_bits(0x80000000)
    out = srl_bits(a, 1)
    assert _hex_u32(out) == "0x40000000"


def test_srl_to_zero():
    a = u32_to_bits(0x00000001)
    out = srl_bits(a, 1)
    assert _hex_u32(out) == "0x00000000"


def test_sra_sign_extend_negative():
    a = u32_to_bits(0x80000001)
    out = sra_bits(a, 1)
    assert _hex_u32(out) == "0xC0000000"


def test_sra_sign_extend_positive():
    a = u32_to_bits(0x7FFFFFFF)
    out = sra_bits(a, 1)
    assert _hex_u32(out) == "0x3FFFFFFF"


def test_edge_shamt_zero():
    a = u32_to_bits(0xA5A5A5A5)
    assert _hex_u32(sll_bits(a, 0)) == "0xA5A5A5A5"
    assert _hex_u32(srl_bits(a, 0)) == "0xA5A5A5A5"
    assert _hex_u32(sra_bits(a, 0)) == "0xA5A5A5A5"


def test_edge_shamt_31_patterns():
    a = u32_to_bits(0x00000001)
    assert _hex_u32(sll_bits(a, 31)) == "0x80000000"
    b = u32_to_bits(0x80000000)
    assert _hex_u32(srl_bits(b, 31)) == "0x00000001"
    assert _hex_u32(sra_bits(b, 31)) == "0xFFFFFFFF"


def test_invalid_shamt():
    a = u32_to_bits(0x12345678)
    with pytest.raises(ValueError):
        sll_bits(a, -1)
    with pytest.raises(ValueError):
        srl_bits(a, 32)
    with pytest.raises(ValueError):
        sra_bits(a, 99)


def test_invalid_bits_length():
    bad = [0, 1, 0]
    with pytest.raises(ValueError):
        sll_bits(bad, 1)
    with pytest.raises(ValueError):
        srl_bits(bad, 1)
    with pytest.raises(ValueError):
        sra_bits(bad, 1)```

########################################
Here is my code for test_twos.py BELOW:
########################################

```python
# tests/unit/test_twos.py
import pytest

from midterm_440.numeric_core.bits import u32_to_bits
from midterm_440.numeric_core.twos import (
    decode_twos_complement,
    encode_twos_complement,
    sign_extend,
    zero_extend,
)


def test_encode_positive():
    out = encode_twos_complement(13)
    assert out["overflow_flag"] == 0
    assert out["hex"] == "0x0000000D"
    assert out["bin"].endswith("00001101")


def test_encode_negative():
    out = encode_twos_complement(-13)
    assert out["overflow_flag"] == 0
    assert out["hex"] == "0xFFFFFFF3"
    assert out["bin"].endswith("11110011")


def test_encode_overflow_high():
    out = encode_twos_complement(1 << 31)
    assert out["overflow_flag"] == 1
    assert out["hex"] == "0x80000000"


def test_decode_from_binary_string_positive():
    val = decode_twos_complement("00000000_00000000_00000000_00001101")["value"]
    assert val == 13


def test_decode_from_binary_string_negative():
    val = decode_twos_complement("11111111_11111111_11111111_11110011")["value"]
    assert val == -13


def test_decode_from_int_unsigned():
    val = decode_twos_complement(0x80000000)["value"]
    assert val == -2147483648


def test_sign_extend_keep_positive():
    b = u32_to_bits(0x7B)
    out = sign_extend(b, 8, 12)
    assert len(out) == 12
    assert out[11] == 0 and out[10] == 0 and out[9] == 0 and out[8] == 0


def test_sign_extend_keep_negative():
    b = u32_to_bits(0xAB)
    out = sign_extend(b, 8, 12)
    assert out[11] == 1 and out[10] == 1 and out[9] == 1 and out[8] == 1


def test_zero_extend_simple():
    b = u32_to_bits(0xAB)
    out = zero_extend(b, 8, 12)
    assert out[11] == 0 and out[10] == 0 and out[9] == 0 and out[8] == 0


def test_decode_bad_string_length():
    with pytest.raises(ValueError):
        decode_twos_complement("1010")


def test_decode_bad_int_range():
    with pytest.raises(ValueError):
        decode_twos_complement(0x1_0000_0000)


def test_sign_extend_bad_widths():
    b = [0] * 32
    with pytest.raises(ValueError):
        sign_extend(b, 0, 12)
    with pytest.raises(ValueError):
        sign_extend(b, 8, 4)


def test_zero_extend_bad_bits():
    bad = [0] * 31 + [2]
    with pytest.raises(ValueError):
        zero_extend(bad, 8, 12)

```
