Developer: Developer: # Project Title
- class elective advisor Project class 491

# Role and Objective
- Serve as a Python developer working on the 'Smart Elective Advisor: AI-Driven Course Selection Tool for CS Students' using modern Python tooling and best practices.
- **Programming language:** Python (already installed).
- **Manages virtual environments:** Poetry (already installed).
- **Package installer for Python:** Poetry.
- **Operating System:** Windows 11.
- **Framework:** LangChain, LangGraph.

# Initial Checklist
- Begin each task with a concise checklist (3-7 bullets) of conceptual sub-tasks to ensure all steps and requirements are addressed.

# Instructions
- Use Visual Studio Code on Windows 11 to develop in Python.
- Manage packages and virtual environments with Poetry.
- Use Tkinter for the GUI, SQLite for the database, and incorporate LangChain, LangGraph, and OpenAI (gpt-4o) for AI components.
- Employ Git and GitHub for version control.
- Use Sphinx for documentation generation.
- **Check my code for errors and suggest improvements.**

## Coding and Commenting Guidelines
- When adding new lines of code, annotate with `` at the end of the line.
- If a line is both added and modified, use only `#  Changed Code` at the end of the line.
- Do **not** comment on command-line instructions.
- Provide complete code context when submitting changes.
- When editing code:
  1. Clearly state any relevant assumptions.
  2. If feasible, create or execute minimal tests to verify changes, and validate results in 1-2 lines (proceed or self-correct as needed).
  3. Provide review-ready diffs.
  4. Follow the established project style conventions.
- **Only annotate a line with `#  Changed Code` if the line is different from the original; do not add `#  Changed Code` when the line remains unchanged.**

# Context
- **Project Directory:** C:/Users/Me/Documents/Python/CPSC491/Projects/class_elective_advisor_491
- **GitHub Repository:** https://github.com/Devilfish281/class_elective_advisor.git
- All required programs and libraries (Python, Tkinter, Poetry, Git) are already installed.

# Output Format
- Default to plain text output unless Markdown is specifically required.
- When using Markdown for code, employ fenced code blocks with correct language tags (e.g., ```python).
- File, directory, function, and class names should appear in backticks if referenced.
- Escape math notation if present.

# Verbosity
- Use concise summaries for general output.
- For code, prioritize high verbosity: use descriptive names, clear logic, and meaningful comments.

# Reasoning Effort
- Set reasoning_effort according to task complexity (minimal for simple, medium/high for complex tasks); tool interactions and code edits should be terse, final outputs more complete as needed.

# Stop Conditions
- Tasks are complete when all success criteria and instructions have been addressed.
- In cases of uncertainty, proceed with the most logical approach and document any relevant assumptions.
- Only finish when the user's specification and project conventions are fully satisfied.

********************************
Check my code for errors and improvements.



The File structure for my program is BELOW:
├── C:\Users\Me\Documents\Python\CPSC440\Projects\midterm_440/
│   ├── .gitignore
│   ├── README.md
│   ├── poetry.lock
│   └── pyproject.toml
    ├── src/
        └── midterm_440/
            └── __init__.py
            └── numeric_core/
                ├── __init__.py
                ├── alu.py
                ├── bits.py
                ├── fpu_f32.py
                ├── interfaces.py
                ├── mdu.py
                ├── shifter.py
                └── twos.py
                └── internal/
    └── tests/
        ├── __init__.py
        └── conftest.py
        ├── data/
        └── unit/
            ├── test_alu.py
            ├── test_bits.py
            ├── test_fpu_f32.py
            ├── test_mdu.py
            └── test_twos.py

########################################
Here is my code for __init__.py BELOW:
########################################

```python
```

########################################
Here is my code for __init__.py BELOW:
########################################

```python
```

########################################
Here is my code for alu.py BELOW:
########################################

```python
# src/midterm_440/numeric_core/alu.py
"""Ripple-carry ALU for ADD/SUB with flags N,Z,C,V (RV32).

The ALU operates on 32-bit bit arrays (LSB first) using 1-bit full adders.
No host ``+``/``-`` or shifts are used in the final implementation.

Overflow (V) rules (two's complement):
- ADD: overflow iff operands share sign and result sign differs.
- SUB: implement as ``a + (~b + 1)`` and apply ADD rule.

Flags:
- N: msb(result)
- Z: 1 if all result bits are 0
- C: carry out of MSB (for subtraction via a + (~b + 1), C=1 implies no borrow)
- V: signed overflow as above
"""

from typing import List, Tuple


def add_bits(a: List[int], b: List[int]) -> Tuple[List[int], int, int, int, int]:
    """Add two 32-bit vectors using a ripple of 1-bit full adders.

    :param List[int] a: 32-bit list, LSB first.
    :param List[int] b: 32-bit list, LSB first.
    :returns: ``(sum_bits, N, Z, C, V)``.
    :rtype: Tuple[List[int], int, int, int, int]
    """
    raise NotImplementedError("add_bits not implemented")


def sub_bits(a: List[int], b: List[int]) -> Tuple[List[int], int, int, int, int]:
    """Subtract ``b`` from ``a`` via two's-complement addition.

    :param List[int] a: Minuend, 32-bit list, LSB first.
    :param List[int] b: Subtrahend, 32-bit list, LSB first.
    :returns: ``(diff_bits, N, Z, C, V)``; for two's-complement, C=1 means no borrow.
    :rtype: Tuple[List[int], int, int, int, int]
    """
    raise NotImplementedError("sub_bits not implemented")```

########################################
Here is my code for bits.py BELOW:
########################################

```python
# src/midterm_440/numeric_core/bits.py
"""Bit-array utilities for the Midterm Numeric Ops Simulator.

This module defines helpers for representing unsigned 32-bit values as
lists of bits (least significant bit first) and for pretty-printing.

This reduces bugs and makes tests readable.

.. important::
   To keep implementation tractable, this module permits bitwise reads
   (``&``, ``>>``) solely for conversion/formatting. Core arithmetic
   (ALU/MDU/FPU) must still avoid host arithmetic/shift ops as required.
"""

from typing import List

_HEX_DIGITS = "0123456789ABCDEF"
_NIBBLE_TO_HEX = {
    (0, 0, 0, 0): "0",
    (0, 0, 0, 1): "1",
    (0, 0, 1, 0): "2",
    (0, 0, 1, 1): "3",
    (0, 1, 0, 0): "4",
    (0, 1, 0, 1): "5",
    (0, 1, 1, 0): "6",
    (0, 1, 1, 1): "7",
    (1, 0, 0, 0): "8",
    (1, 0, 0, 1): "9",
    (1, 0, 1, 0): "A",
    (1, 0, 1, 1): "B",
    (1, 1, 0, 0): "C",
    (1, 1, 0, 1): "D",
    (1, 1, 1, 0): "E",
    (1, 1, 1, 1): "F",
}


def _validate_bits_32(bits: List[int]) -> None:
    """Internal: ensure a 32-length 0/1 list (LSB first).

    :param List[int] bits: Candidate bit list.
    :raises ValueError: If malformed.
    """
    if not isinstance(bits, list):
        raise ValueError("bits must be a list")
    if len(bits) != 32:
        raise ValueError("bits must contain exactly 32 elements")
    for b in bits:
        if b not in (0, 1):
            raise ValueError("bits must contain only 0 or 1")


def u32_to_bits(value: int) -> List[int]:
    """Convert an unsigned 32-bit integer to a 32-length bit list (LSB first).

    :param int value: Unsigned integer expected in range ``[0, 2**32-1]``.
    :returns: Bit list ``bits[0]`` = LSB, ``bits[31]`` = MSB.
    :rtype: List[int]
    :raises ValueError: If value is outside 32-bit unsigned range.
    """
    if not isinstance(value, int):
        raise ValueError("value must be an int")
    if value < 0 or value > 0xFFFF_FFFF:
        raise ValueError("value must be in 0..0xFFFFFFFF")

    bits = [0] * 32
    for i in range(32):
        bits[i] = (value >> i) & 1
    return bits


def bits_to_u32(bits: List[int]) -> int:
    """Convert a 32-length bit list (LSB first) to an unsigned 32-bit integer.

    :param List[int] bits: Exactly 32 elements, each 0 or 1.
    :returns: Unsigned 32-bit integer.
    :rtype: int
    :raises ValueError: If length != 32 or elements are not 0/1.
    """
    _validate_bits_32(bits)
    value = 0
    for i in range(32):
        if bits[i]:
            value |= 1 << i
    return value


def pretty_bin32(bits: List[int]) -> str:
    """Return a grouped binary string like ``00000000_00000000_00000000_00000000``.

    Bytes are grouped from MSB to LSB, separated by underscores,
    with each byte printed MSB-first inside the group.

    :param List[int] bits: 32-bit list, LSB first.
    :returns: Human-friendly grouped binary string.
    :rtype: str
    """
    _validate_bits_32(bits)
    msb_first = "".join("1" if b else "0" for b in reversed(bits))
    groups = [msb_first[i : i + 8] for i in range(0, 32, 8)]
    return "_".join(groups)


def pretty_hex32(bits: List[int]) -> str:
    """Return a zero-padded hex string like ``0xDEADBEEF`` (manual nibbles).

    :param List[int] bits: 32-bit list, LSB first.
    :returns: Hex string with prefix ``0x``.
    :rtype: str
    """
    _validate_bits_32(bits)
    msb_first = list(reversed(bits))
    hex_chars: List[str] = []
    for i in range(0, 32, 4):
        n4 = tuple(int(c) for c in msb_first[i : i + 4])
        if len(n4) != 4:
            raise ValueError("internal error: nibble length != 4")
        hex_chars.append(_NIBBLE_TO_HEX[n4])
    return "0x" + "".join(hex_chars)


def main() -> int:
    """Small demo you can run by executing this file directly."""
    from midterm_440.numeric_core.bits import (
        bits_to_u32,
        pretty_bin32,
        pretty_hex32,
        u32_to_bits,
    )

    b = u32_to_bits(0xDEADBEEF)
    print(pretty_bin32(b))
    print(pretty_hex32(b))
    print(hex(bits_to_u32(b)))
    return 0


if __name__ == "__main__":

    import sys
    from pathlib import Path

    here = Path(__file__).resolve()
    project_root = here.parents[2]
    src_dir = project_root / "src"

    if src_dir.name == "src" and src_dir.exists():
        sys.path.insert(0, str(src_dir))

    raise SystemExit(main())```

########################################
Here is my code for fpu_f32.py BELOW:
########################################

```python
# src/midterm_440/numeric_core/fpu_f32.py
"""IEEE 754 float32 pack/unpack and arithmetic (add/sub/mul).

Implements bit-level operations: pack/unpack (s|exp|frac), align, add/sub on
extended significands, normalize, and round with **RoundTiesToEven (RNE)**.

Flags surfaced for grading: overflow, underflow, invalid (and optionally inexact).
"""

from typing import Dict, List


def pack_f32(value: float) -> Dict[str, object]:
    """Pack a Python decimal value into an IEEE-754 binary32 bit pattern.

    :param float value: Decimal input; treat special cases (±0, ±inf, NaN).
    :returns: ``{'bits': List[int], 'fields': {'s': int, 'exp': List[int], 'frac': List[int]}}``.
    :rtype: Dict[str, object]
    """
    raise NotImplementedError("pack_f32 not implemented")


def unpack_f32(bits: List[int]) -> Dict[str, object]:
    """Unpack a 32-bit IEEE-754 pattern into a Python decimal value.

    :param List[int] bits: 32 bits, LSB first.
    :returns: ``{'value': float, 'class': str}`` (e.g., 'normal','subnormal','zero','inf','nan').
    :rtype: Dict[str, object]
    """
    raise NotImplementedError("unpack_f32 not implemented")


def fadd_f32(a_bits: List[int], b_bits: List[int]) -> Dict[str, object]:
    """Float32 addition via align → add → normalize → round (RNE).

    :param List[int] a_bits: Operand A, 32 bits LSB first.
    :param List[int] b_bits: Operand B, 32 bits LSB first.
    :returns: ``{'res_bits': List[int], 'flags': {'overflow': int, 'underflow': int, 'invalid': int}, 'trace': List[dict]}``.
    :rtype: Dict[str, object]
    """
    raise NotImplementedError("fadd_f32 not implemented")


def fsub_f32(a_bits: List[int], b_bits: List[int]) -> Dict[str, object]:
    """Float32 subtraction via add with sign inversion and standard steps.

    :param List[int] a_bits: Operand A, 32 bits LSB first.
    :param List[int] b_bits: Operand B, 32 bits LSB first.
    :returns: Same schema as :func:`fadd_f32`.
    :rtype: Dict[str, object]
    """
    raise NotImplementedError("fsub_f32 not implemented")


def fmul_f32(a_bits: List[int], b_bits: List[int]) -> Dict[str, object]:
    """Float32 multiplication with normalization and RNE rounding.

    :param List[int] a_bits: Operand A, 32 bits LSB first.
    :param List[int] b_bits: Operand B, 32 bits LSB first.
    :returns: ``{'res_bits': List[int], 'flags': {...}, 'trace': List[dict]}``.
    :rtype: Dict[str, object]
    """
    raise NotImplementedError("fmul_f32 not implemented")```

########################################
Here is my code for interfaces.py BELOW:
########################################

```python
# src/midterm_440/numeric_core/interfaces.py
"""Public API surface for the Midterm Numeric Core.

This thin layer centralizes import paths for the numeric core so the
later CPU project can integrate a stable, pure-functional interface.
"""

from typing import Any, Dict, List, Tuple

try:
    from .alu import add_bits, sub_bits
    from .bits import bits_to_u32, pretty_bin32, pretty_hex32, u32_to_bits
    from .fpu_f32 import fadd_f32, fmul_f32, fsub_f32, pack_f32, unpack_f32
    from .mdu import div_restoring, mul_shift_add
    from .shifter import sll_bits, sra_bits, srl_bits
    from .twos import (
        decode_twos_complement,
        encode_twos_complement,
        sign_extend,
        zero_extend,
    )
except Exception:
    pass


def main() -> int:
    """Optional CLI entry point for manual smoke tests.

    :returns: Process exit code (0 success).
    :rtype: int
    """
    return 0```

########################################
Here is my code for mdu.py BELOW:
########################################

```python
# src/midterm_440/numeric_core/mdu.py
"""Multiply/Divide Unit (MDU) for RV32M using bit-level algorithms.

**Multiply (shift-add)** and **Divide (restoring or non-restoring)** are implemented
as multi-step algorithms that expose per-iteration traces.

Division edge cases (per RISC-V M):
- DIV x/0 → q = -1 (0xFFFFFFFF), r = dividend (for signed DIV).
- DIVU x/0 → q = 0xFFFFFFFF, r = dividend (for unsigned DIVU).
- DIV INT_MIN / -1 → q = INT_MIN (0x80000000), r = 0.

Overflow grading hint: set an overflow flag when the true 64-bit product
is not representable as a signed 32-bit result (even though RV32M truncates).
"""

from typing import Dict, List, Tuple


def mul_shift_add(rs1_bits: List[int], rs2_bits: List[int]) -> Dict[str, object]:
    """Signed 32×32 → low32 product via classic shift-add with trace.

    :param List[int] rs1_bits: Multiplicand, 32-bit LSB-first.
    :param List[int] rs2_bits: Multiplier, 32-bit LSB-first.
    :returns: ``{'rd_bits': List[int], 'overflow': int, 'trace': List[dict]}``.
    :rtype: Dict[str, object]
    """
    raise NotImplementedError("mul_shift_add not implemented")


def div_restoring(
    dividend_bits: List[int], divisor_bits: List[int], signed: bool = True
) -> Dict[str, object]:
    """Restoring division with per-iteration remainder/quotient trace.

    :param List[int] dividend_bits: 32-bit dividend, LSB first.
    :param List[int] divisor_bits: 32-bit divisor, LSB first.
    :param bool signed: If True perform signed DIV/REM; else DIVU/REMU.
    :returns: ``{'q_bits': List[int], 'r_bits': List[int], 'flags': dict, 'trace': List[dict]}``.
    :rtype: Dict[str, object]
    :raises ZeroDivisionError: For divisor==0 (you may intercept to match RV32M).
    """
    raise NotImplementedError("div_restoring not implemented")```

########################################
Here is my code for shifter.py BELOW:
########################################

```python
# src/midterm_440/numeric_core/shifter.py
"""Logical and arithmetic shifters implemented without ``<<``/``>>``.

Implements SLL, SRL, SRA using either iterative shift-register style
or a barrel shifter built from stages (powers of two).
"""

from typing import List


def sll_bits(bits: List[int], shamt: int) -> List[int]:
    """Shift left logical by ``shamt`` (insert zeros on the right).

    :param List[int] bits: 32-bit list, LSB first.
    :param int shamt: Shift amount in [0, 31].
    :returns: New 32-bit list after SLL.
    :rtype: List[int]
    """
    raise NotImplementedError("sll_bits not implemented")


def srl_bits(bits: List[int], shamt: int) -> List[int]:
    """Shift right logical by ``shamt`` (insert zeros on the left).

    :param List[int] bits: 32-bit list, LSB first.
    :param int shamt: Shift amount in [0, 31].
    :returns: New 32-bit list after SRL.
    :rtype: List[int]
    """
    raise NotImplementedError("srl_bits not implemented")


def sra_bits(bits: List[int], shamt: int) -> List[int]:
    """Shift right arithmetic by ``shamt`` (replicate original sign bit).

    :param List[int] bits: 32-bit list, LSB first.
    :param int shamt: Shift amount in [0, 31].
    :returns: New 32-bit list after SRA.
    :rtype: List[int]
    """
    raise NotImplementedError("sra_bits not implemented")```

########################################
Here is my code for twos.py BELOW:
########################################

```python
# src/midterm_440/numeric_core/twos.py
"""Two's-complement tools for 32-bit values (RV32).

This file gives you simple helpers to work with signed 32-bit numbers.
You can turn a Python int into two's-complement bits and back.
You can also grow a smaller value to a bigger width by copying the sign
(sign-extend) or by adding zeros (zero-extend).

Reminder about overflow in two's-complement math:
- Overflow is about the sign being wrong, not about the carry bit.
- If you add two numbers with the same sign and the result flips sign,
  that means overflow.
Example: 0x7FFFFFFF + 1 → 0x80000000 has signed overflow.
"""

from typing import Dict, List

from midterm_440.numeric_core.bits import (
    bits_to_u32,
    pretty_bin32,
    pretty_hex32,
    u32_to_bits,
)

_INT32_MIN = -(1 << 31)
_INT32_MAX = (1 << 31) - 1
_MASK32 = 0xFFFF_FFFF


def _validate_bit_string_32(s: str) -> str:
    """Make sure we got a clean 32-bit '0'/'1' string. Underscores are ok.
    Returns the cleaned 32 characters (MSB..LSB).
    """
    if not isinstance(s, str):
        raise ValueError("bits_in must be a string or int")

    cleaned = s.replace("_", "").strip()
    if len(cleaned) != 32 or any(ch not in "01" for ch in cleaned):
        raise ValueError("binary string must be 32 characters of '0'/'1'")
    return cleaned


def encode_twos_complement(value: int) -> Dict[str, object]:
    """Turn a Python int into a 32-bit two's-complement pattern.

    :param int value: The number you want to encode (can be negative).
    :returns: A dictionary with:
              ``bin`` (str): 32 bits grouped like ``00000000_...``;
              ``hex`` (str): hex string like ``0x0000000D``;
              ``overflow_flag`` (int): 1 if value is outside -2^31..2^31-1.
    :rtype: Dict[str, object]

    Example: value = -13 → bin looks like 1111...0011, hex=0xFFFFFFF3.

    To get the two's-complement representation of a negative number (for an N-bit word):

    Write the absolute value in binary using N bits (pad with leading zeros).

    Flip every bit (0 → 1, 1 → 0).

    Add 1 to the flipped result (ignore any carry beyond N bits).

    Example: represent -5 in 8 bits.
    +5 in 8 bits = 00000101.
    Flip bits → 11111010.
    Add 1 → 11111011 (this is -5 in 8-bit two's-complement).

    """
    if not isinstance(value, int):
        raise ValueError("value must be an int")
    overflow = 0 if (_INT32_MIN <= value <= _INT32_MAX) else 1
    unsigned = value & _MASK32
    bits = u32_to_bits(unsigned)
    return {
        "bin": pretty_bin32(bits),
        "hex": pretty_hex32(bits),
        "overflow_flag": overflow,
    }


def decode_twos_complement(bits_in: object) -> Dict[str, int]:
    """Read a 32-bit pattern and return the signed value.

    :param object bits_in: A 32-char '0'/'1' string (underscores ok)
                           or an unsigned 32-bit integer.
    :returns: ``{'value': int}`` in [-2**31, 2**31-1].
    :rtype: Dict[str, int]

    Tip: If the top bit (bit 31) is 1, the number is negative.
    """
    if isinstance(bits_in, str):
        cleaned = _validate_bit_string_32(bits_in)
        bits = [1 if cleaned[31 - i] == "1" else 0 for i in range(32)]
        u = bits_to_u32(bits)
    elif isinstance(bits_in, int):
        if bits_in < 0 or bits_in > _MASK32:
            raise ValueError("integer input must be in 0..0xFFFFFFFF")
        u = bits_in
    else:
        raise ValueError("bits_in must be a 32-bit binary string or unsigned int")

    value = u if (u & (1 << 31)) == 0 else (u - (1 << 32))
    return {"value": value}


def sign_extend(bits: List[int], from_width: int, to_width: int) -> List[int]:
    """Grow a value by copying its sign bit.

    :param List[int] bits: Bits are LSB first (bits[0] is the rightmost bit).
    :param int from_width: How many low bits are the “real” value now.
    :param int to_width: New width (must be >= from_width).
    :returns: New list with length ``to_width``.

    Why this works: in two's complement, repeating the top bit keeps the value.
    (If sign=1, we fill with 1s; if sign=0, we fill with 0s.)
    """
    if not isinstance(bits, list) or any(b not in (0, 1) for b in bits):
        raise ValueError("bits must be a list of 0/1")
    if not (1 <= from_width <= len(bits)):
        raise ValueError("from_width must be in 1..len(bits)")
    if to_width < from_width:
        raise ValueError("to_width must be >= from_width")

    sign = bits[from_width - 1]
    out = bits[:from_width] + [sign] * (to_width - from_width)
    return out[:to_width]


def zero_extend(bits: List[int], from_width: int, to_width: int) -> List[int]:
    """Grow a value by adding zeros on the left.

    :param List[int] bits: Bits are LSB first (bits[0] is the rightmost bit).
    :param int from_width: How many low bits are the “real” value now.
    :param int to_width: New width (must be >= from_width).
    :returns: New list with length ``to_width``.

    Use this when you want an unsigned view or you know the value is non-negative.
    """
    if not isinstance(bits, list) or any(b not in (0, 1) for b in bits):
        raise ValueError("bits must be a list of 0/1")
    if not (1 <= from_width <= len(bits)):
        raise ValueError("from_width must be in 1..len(bits)")
    if to_width < from_width:
        raise ValueError("to_width must be >= from_width")

    out = bits[:from_width] + [0] * (to_width - from_width)
    return out[:to_width]


def main() -> int:
    """Small demo so you can run this file directly.

    This only runs when you execute the module as a script,
    not when you import it in other code.
    """
    print(encode_twos_complement(13))
    print(encode_twos_complement(-13))
    print(decode_twos_complement("00000000_00000000_00000000_00001101"))
    print(decode_twos_complement("11111111_11111111_11111111_11110011"))
    b = u32_to_bits(0xAB)
    print(sign_extend(b, 8, 12))
    print(zero_extend(b, 8, 12))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())```

########################################
Here is my code for __init__.py BELOW:
########################################

```python
```

########################################
Here is my code for conftest.py BELOW:
########################################

```python
```

########################################
Here is my code for test_alu.py BELOW:
########################################

```python
```

########################################
Here is my code for test_bits.py BELOW:
########################################

```python
# tests/unit/test_bits.py
import pytest

from midterm_440.numeric_core.bits import (
    bits_to_u32,
    pretty_bin32,
    pretty_hex32,
    u32_to_bits,
)


class TestBits:
    def test_round_trip_zero(self):
        b = u32_to_bits(0)
        assert len(b) == 32 and all(x in (0, 1) for x in b)
        assert bits_to_u32(b) == 0

    def test_round_trip_max(self):
        val = 0xFFFF_FFFF
        b = u32_to_bits(val)
        assert bits_to_u32(b) == val

    def test_specific_value_deadbeef(self):
        val = 0xDEAD_BEEF
        b = u32_to_bits(val)
        bin_str = pretty_bin32(b)
        assert isinstance(bin_str, str) and len(bin_str.replace("_", "")) == 32
        assert pretty_hex32(b) == "0xDEADBEEF"
        assert bits_to_u32(b) == val

    def test_invalid_range_negative(self):
        with pytest.raises(ValueError):
            u32_to_bits(-1)

    def test_invalid_range_too_large(self):
        with pytest.raises(ValueError):
            u32_to_bits(0x1_0000_0000)

    def test_bits_validation_length(self):
        with pytest.raises(ValueError):
            bits_to_u32([0, 1])

    def test_bits_validation_values(self):
        bad = [0] * 31 + [2]
        with pytest.raises(ValueError):
            bits_to_u32(bad)

    def test_formatting_zero(self):
        b = u32_to_bits(0)
        assert pretty_hex32(b) == "0x00000000"
        assert pretty_bin32(b) == "00000000_00000000_00000000_00000000"```

########################################
Here is my code for test_fpu_f32.py BELOW:
########################################

```python
```

########################################
Here is my code for test_mdu.py BELOW:
########################################

```python
```

########################################
Here is my code for test_twos.py BELOW:
########################################

```python
# tests/unit/test_twos.py
import pytest

from midterm_440.numeric_core.bits import u32_to_bits
from midterm_440.numeric_core.twos import (
    decode_twos_complement,
    encode_twos_complement,
    sign_extend,
    zero_extend,
)


def test_encode_positive():
    out = encode_twos_complement(13)
    assert out["overflow_flag"] == 0
    assert out["hex"] == "0x0000000D"
    assert out["bin"].endswith("00001101")


def test_encode_negative():
    out = encode_twos_complement(-13)
    assert out["overflow_flag"] == 0
    assert out["hex"] == "0xFFFFFFF3"
    assert out["bin"].endswith("11110011")


def test_encode_overflow_high():
    out = encode_twos_complement(1 << 31)
    assert out["overflow_flag"] == 1
    assert out["hex"] == "0x80000000"


def test_decode_from_binary_string_positive():
    val = decode_twos_complement("00000000_00000000_00000000_00001101")["value"]
    assert val == 13


def test_decode_from_binary_string_negative():
    val = decode_twos_complement("11111111_11111111_11111111_11110011")["value"]
    assert val == -13


def test_decode_from_int_unsigned():
    val = decode_twos_complement(0x80000000)["value"]
    assert val == -2147483648


def test_sign_extend_keep_positive():
    b = u32_to_bits(0x7B)
    out = sign_extend(b, 8, 12)
    assert len(out) == 12
    assert out[11] == 0 and out[10] == 0 and out[9] == 0 and out[8] == 0


def test_sign_extend_keep_negative():
    b = u32_to_bits(0xAB)
    out = sign_extend(b, 8, 12)
    assert out[11] == 1 and out[10] == 1 and out[9] == 1 and out[8] == 1


def test_zero_extend_simple():
    b = u32_to_bits(0xAB)
    out = zero_extend(b, 8, 12)
    assert out[11] == 0 and out[10] == 0 and out[9] == 0 and out[8] == 0


def test_decode_bad_string_length():
    with pytest.raises(ValueError):
        decode_twos_complement("1010")


def test_decode_bad_int_range():
    with pytest.raises(ValueError):
        decode_twos_complement(0x1_0000_0000)


def test_sign_extend_bad_widths():
    b = [0] * 32
    with pytest.raises(ValueError):
        sign_extend(b, 0, 12)
    with pytest.raises(ValueError):
        sign_extend(b, 8, 4)


def test_zero_extend_bad_bits():
    bad = [0] * 31 + [2]
    with pytest.raises(ValueError):
        zero_extend(bad, 8, 12)

```
